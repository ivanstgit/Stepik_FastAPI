# Развертывание с помощью ASGI-серверов
ASGI (Asynchronous Server Gateway Interface) - это интерфейс между веб-серверами и веб-приложениями на Python. FastAPI построен на ASGI и может быть развернут с использованием ASGI-серверов, таких как Uvicorn, Hypercorn или Daphne. Серверы ASGI предназначены для эффективной работы с асинхронными веб-фреймворками, такими как FastAPI, что делает их предпочтительным выбором для производственных развертываний.

Давайте посмотрим на них чуть подробнее:

1. Uvicorn - это легкий ASGI-сервер, специально разработанный для быстрых ASGI-фреймворков, таких как FastAPI и Starlette. Он основан на библиотеке uvloop, которая представляет собой сверхбыструю реализацию цикла обработки событий. Uvicorn обеспечивает хорошую производительность и подходит для приложений с высокой степенью параллелизма. Он совместим с библиотекой asyncio. 

2. Hypercorn также является ASGI-сервером, но разработан как более универсальный и готовый к работе с различными программами. Он нацелен на совместимость с широким спектром ASGI-фреймворков и построен поверх библиотеки asyncio. Hypercorn поддерживает HTTP / 1, HTTP / 2 и WebSockets, что делает его универсальным выбором для различных приложений. Стоит отметить, что гиперкорн помимо asyncio поддерживает Trio (более новая библиотека асинхронности, которая по словам разработчиков попроще, чем asyncio).

3. Daphne - это еще один сервер ASGI, и он специально разработан для приложений Django. Он разработан для обслуживания ASGI-совместимых приложений Django и предоставляет производственный интерфейс для запуска Django Channels и обработки подключений WebSocket.

Таким образом, Uvicorn ориентирован на скорость и производительность, Hypercorn стремится стать более гибким и готовым к работе ASGI-сервером, а Daphne оптимизирован для запуска приложений Django с поддержкой ASGI.

По-умолчанию рекомендуем Uvicorn, если вы не находитесь на продвинутом уровне, так как FastAPI под него "заточен". Наилучший выбор среди этих серверов зависит от конкретных требований и фреймворков, используемых в вашем веб-приложений.

Теоретически можно развернуть приложение только при помощи uvicorn'a, но тогда будет несколько минусов, таких как отсутствие https и то, что будет всего один процесс. Этот вариант подходит только для неопытных. Для этого можно указать на каком хосте и порту он будет работать. Чтобы он мониторил все айпи машины, его запускают с командой --host 0.0.0.0.

# docker
Так как потребности в архитектуре бэкенда у всех разные, то мы не можем дать универсальный рецепт для всех. Мануалов имеется достаточно, и это довольно интересный опыт вывода в продакшн. 

Но если бы стоял вопрос о том, как сделать это максимально просто самому (с хорошим потенциалом масштабирования), то можно было бы посоветовать использовать официальный докер-образ связки uvicorn-gunicorn-fastapi, который можно найти по ссылке (там же можно прочитать про запуск):

https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker

Для старта соответственно можете для сначала поставить только эту связку гуникорн-ювикорн-фастапи (гуникорн на порту 80 передаёт всё единственному ювикорну, а тот работает с фастапи). Потом делаете несколько процессов увикорна, а гуникорн перенаправляет запросы им. А потом уже усложняет дальше. 

Например, в реальных проектах, можно сделать такую связку: докер-образ Nginx'а выступает в роли фронт-сервера на портах :80 (http), :443 (https) (балансировщика*, который распределяет нагрузку по другим бэк-серверам; для https ему нужен будет Certbot). Далее идёт Gunicorn (wsgi-сервер), который выступает в роли менеджера процессов (пидов) uvicorn'а. Uvicorn уже взаимодействуют напрямую с FastAPI. Все это крутится в виде докер-образов.

Мануал по такой связке (на английском языке, но без Docker'а):

https://dylancastillo.co/fastapi-nginx-gunicorn/

Эта инструкция подойдёт, если у вас есть свой/арендованный выделенный/виртуальный сервер. Мы бы могли порекомендовать RuVDS, там можно взять себе для тестов VPS за символические 40 рублей в месяц (https://ruvds.com/cheap_vps/).

За FastAPI уже стоят Redis/Memcached (для кэша) + Postgres SQL (для хранения данных). 

*подробнее про балансировку через Nginx:

https://habr.com/ru/companies/first/articles/683870/

# Мониторинг и ведение журнала
Развернутые приложения FastAPI следует отслеживать и регистрировать в журнале, чтобы отслеживать производительность, выявлять проблемы и обеспечивать бесперебойную работу. Инструменты мониторинга, такие как Prometheus и Grafana, могут быть интегрированы в приложения FastAPI для сбора и визуализации показателей производительности (можно туда добавить Loki). Правильное ведение журнала гарантирует, что ошибки и важные события будут записаны, что облегчает диагностику и устранение неполадок.

Чтобы самостоятельно в этом покопаться, можете изучить эти гайды:

https://timeweb.cloud/tutorials/servers/ustanovka-i-nastrojka-prometheus

https://timeweb.cloud/tutorials/linux/ustanovka-i-nastrojka-grafana

Второй, более мощный, мониторинговый стэк называется ELK. От ключевых технологий, применяемых в нём - elasticsearch, logstash, kibana. Это довольно сложно настраиваемая и поднимаемая технология, которая будет "жрать" довольно много ресурсов (в частности оперативной памяти), но которая даёт колоссально информативно аналитику. На первых порах рекомендуем воздержаться от внедрения, но слышать о них рекомендется (хотя бы почитать и понимать что это и с чем это едят). Но если вам удастся поднять её в своём проекте, то вы будете видеть всю жизнь каждого запроса (какие функции отработали и за какое время, какие были запросы в базу данных и сколько они длились по времени, какие ошибки возникли и тп). С помощью неё получится увидеть не оптимальные точки в Вашем приложении и в дальнейшем улучшить его перфоманс (в том числе можно увидеть проблему N+1 при работе с базой данных). Начать знакомство можно с этой статьи:

https://habr.com/ru/articles/671344/

Кстати при логгировании можете попробовать использовать Loguru вместо стандартной библиотеки logging. Ознакомиться можно по статье ниже:

https://habr.com/ru/articles/454436/

Еще на просторах интернета Вы можете наткнуться на инструмент fastapi-profiler. Рекомендуем воздержаться от его использования: он слишком сильно тормозит приложение и не очень удобен в использовании, хотя и подключить его можно буквально одной строчкой в коде.

И последнее, что мы Вам точно бы порекомендовали (это крайне свежая библиотека), это logfire. Он очень прост в начале использования, и при этом даёт крутую и удобную систему мониторинга приложения.

https://pydantic.dev/logfire

На данный момент это все ещё beta-версия библиотеки, поэтому не исключаюся баги.

Давайте посмотрим как подключить её в приложение. 
Для начала нужно установить (желательно в виртуальном окружении) эту библиотеку (обратите внимание на дополнительное указание пакета - без него у вас не получится подружить logfire с fastapi):

pip install logfire[fastapi]
Следующим шагом нужно авторизоваться через консоль, просто пишем в консоли:

logfire auth
Он потом предложит перейти в браузер (клик ￼Enter и входите через свой github-профиль). 

Далее просто подключаем её к вашему приложению (1 строчкой) и наслаждаемся информацией и аналитикой:

from fastapi import FastAPI
import uvicorn
import logfire


app = FastAPI()
logfire.instrument_fastapi(app)  # тут просто передаем в logfire наше приложение


@app.get("/")
def read_root():
    return {"Hello": "World"}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000)
После запуска приложения он предложит выбрать (создать) проект (следуйте инструкциям, которые будут в консоли). Изучать и настраивать необходимое отображение сможете в своём профиле:

https://logfire.pydantic.dev/

Попробуйте отправить запрос в интерактивной документации / через Postman и посмотреть, что Вам стало известно. 

# Нагрузочное тестирование
Перед развертыванием приложения FastAPI в рабочей среде следует провести нагрузочное тестирование, чтобы оценить его производительность при различных нагрузках. Инструменты нагрузочного тестирования, такие как Locust или JMeter, можно использовать для моделирования большого числа одновременных пользователей и оценки времени отклика приложения и масштабируемости.